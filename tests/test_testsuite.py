import skycoin
import base64

# InputTestDataJSON contains hashes to be signed
class InputTestDataJSON():
	Hashes = []


# KeysTestDataJSON contains address, public key,  secret key and list of signatures
class KeysTestDataJSON():
	Address = ""
	Secret = ""
	Public = ""
	Signatures = []


# SeedTestDataJSON contains data generated by Seed
class SeedTestDataJSON():
	Seed = ""
	Keys = []


# InputTestData contains hashes to be signed
class InputTestData():
	Hashes = []


# ToJSON converts InputTestData to InputTestDataJSON
def ToJSON_InputTestData(InputTestData):
	hashes = []
	for l in InputTestData:
		hashes.appen(l)
	return hashes


# InputTestDataFromJSON converts InputTestDataJSON to InputTestData
def InputTestDataFromJSON(InputTestDataJSON):
	hashes = []
	for h in InputTestDataJSON:
		h2 = skycoin.cipher_SHA256()
		err = skycoin.SKY_cipher_SHA256FromHex(h, h2)
		hashes.appen(h2)
		if err != skycoin.SKY_OK:
			return skycoin.SKY_ERROR 
	return hashes


# KeysTestData contains address, public key,  secret key and list of signatures
class KeysTestData():
	Address = ""
	Secret = ""
	Public = ""
	Signatures = []


# ToJSON converts KeysTestData to KeysTestDataJSON
def ToJSON_KeysTestData(KeysTestData):
	sigs = []
	for s in KeysTestData.Signatures:
		sigs.appen(s)
	k = KeysTestDataJSON()
	k.Address = KeysTestData.Address
	k.Secret = KeysTestData.Secret
	k.Public = KeysTestData.Public
	k.Signatures = sigs
	return k


# KeysTestDataFromJSON converts KeysTestDataJSON to KeysTestData
def KeysTestDataFromJSON(KeysTestDataJSON):
	# _, addres_str = skycoin.SKY_cipher_Address_String(addres)
	addres = skycoin.cipher__Address()
	err = skycoin.SKY_cipher_DecodeBase58Address(KeysTestDataJSON.Address, addres)
	if err != skycoin.SKY_OK:
		return skycoin.SKY_ERROR 
	
	err , secret_key_hex = skycoin.SKY_cipher_SecKey_Hex(KeysTestDataJSON.Secret)
	if err != skycoin.SKY_OK:
		return skycoin.SKY_ERROR 
	
	err , public_key_hex = skycoin.SKY_cipher_PubKey_Hex(KeysTestDataJSON.Secret)
	if err != skycoin.SKY_OK:
		return skycoin.SKY_ERROR 

	sigs = []
	if len(KeysTestDataJSON.Signatures) >= 0:
		for s in KeysTestDataJSON.Signatures:
			err , sig_fromHex = skycoin.SKY_cipher_Sig_Hex(s)
			# err, sig_fromHex = skycoin.SKY_cipher_SigFromHex(p0, p1)
			sigs.append(sig_fromHex)
			if err != skycoin.SKY_OK:
				return skycoin.SKY_ERROR
	r = KeysTestData()
	r.Address = addres
	r.Public = public_key_hex
	r.Secret = secret_key_hex
	r.Signatures = sigs
	return r


# SeedTestData contains data generated by Seed
class SeedTestData():
	Seed = []
	Keys = []


# ToJSON converts SeedTestData to SeedTestDataJSON
def ToJSON_SeedTestData(SeedTestData):
	keys = []
	for k in SeedTestData.Keys:
		kj = ToJSON_KeysTestData(k)
		keys.append(kj)

	r = SeedTestDataJSON()
	r.Seed = base64.standard_b64decode(SeedTestData.Seed)
	r.Keys = keys
	return r


# SeedTestDataFromJSON converts SeedTestDataJSON to SeedTestData
def SeedTestDataFromJSON(SeedTestDataJSON):
	seed = base64.standard_b64decode(SeedTestDataJSON.Seed)
	keys = []
	for kj in SeedTestDataJSON.Keys:
		k = KeysTestDataFromJSON(kj)
		if k == skycoin.SKY_ERROR:
			return skycoin.SKY_ERROR
		keys.append(k)

	r = SeedTestData()
	r.Seed = seed
	r.Keys = keys
	return r


# ValidateSeedData validates the provided SeedTestData against the current cipher library.
# inputData is required if SeedTestData contains signatures
def ValidateSeedData(SeedTestData = None, InputTestData = None):
	err, keys = skycoin.SKY_cipher_GenerateDeterministicKeyPairs(SeedTestData, len(SeedTestData.Keys))
	assert err == skycoin.SKY_OK
	if len(SeedTestData.Keys) != len(keys):
		return skycoin.SKY_ERROR
		
	secret_Key = skycoin.cipher_SecKey
	i = 0
	for s in keys:
		if s == secret_Key:
			return skycoin.SKY_ErrInvalidSecKey
		if SeedTestData.Keys[i].Secret != s:
			return skycoin.SKY_ErrInvalidSecKey
		p = skycoin.cipher_PubKey()
		p_null = skycoin.cipher_PubKey()
		err = skycoin.SKY_cipher_PubKeyFromSecKey(s, p)
		if p == p_null:
			return skycoin.SKY_ErrInvalidPubKey
		if SeedTestData.Keys[i].Public != p:
			return skycoin.SKY_ErrInvalidPubKey
		addr1 = skycoin.cipher__Address()
		addr_null = skycoin.cipher__Address()
		err = skycoin.SKY_cipher_AddressFromPubKey(p, addr1)
		assert err == skycoin.SKY_OK
		if addr1 == addr_null:
			return skycoin.SKY_ErrAddressInvalidPubKey
		if SeedTestData.Keys[i].Address != addr1:
			return skycoin.SKY_ErrAddressInvalidChecksum

		addr2 = skycoin.cipher__Address()
		err = skycoin.SKY_cipher_AddressFromSecKey(s, addr2)
		assert err == skycoin.SKY_OK
		if addr1 != addr2:
			return skycoin.SKY_ErrAddressInvalidChecksum
		err, validSec = skycoin.SKY_secp256k1_VerifySeckey(s)
		if validSec != 1:
			return skycoin.SKY_ERROR
		err, validPub = skycoin.SKY_secp256k1_VerifySeckey(p)
		if validPub != 1:
			return skycoin.SKY_ERROR

		if InputTestData == None and SeedTestData.Keys[i].Signatures != 0: 
			return skycoin.SKY_ERROR

		if InputTestData != None:
			if len(SeedTestData.Keys[i].Signatures) != len(InputTestData.Hashes):
				return skycoin.SKY_ERROR
			
			for j in range(len(InputTestData.Hashes)):
				sig = SeedTestData.Keys[i].Signatures[j]
				sig_null = skycoin.cipher_Sig()
				if sig == sig_null:
					return skycoin.SKY_ERROR

				err = skycoin.SKY_cipher_VerifySignature(p, sig, InputTestData.Hashes[j])
				if err != skycoin.SKY_OK:
					return skycoin.SKY_ERROR

				err = skycoin.SKY_cipher_ChkSig(addr1, InputTestData.Hashes[j], sig)
				if err != skycoin.SKY_OK:
					return skycoin.SKY_ERROR

				err = skycoin.SKY_cipher_VerifySignedHash(sig, InputTestData.Hashes[j])
				if err != skycoin.SKY_OK:
					return skycoin.SKY_ERROR

				p2 = skycoin.cipher_PubKey()
				err = skycoin.SKY_cipher_PubKeyFromSig(sig, InputTestData.Hashes[j], p2)
				if err != skycoin.SKY_OK:
					return skycoin.SKY_ERROR
				if p != p2:
					return skycoin.SKY_ERROR

				sig2 = skycoin.cipher_Sig()
				skycoin.SKY_cipher_SignHash(InputTestData.Hashes[j], s, sig2)
				if sig2 == sig_null:
					return skycoin.SKY_ERROR
	i += 1
				# NOTE: signatures are not deterministic, they use a nonce,
				# so we don't compare the generated sig to the provided sig
